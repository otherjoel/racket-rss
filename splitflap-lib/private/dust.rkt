#lang racket/base

(require (for-syntax racket/base)
         (only-in net/url url? url->string)
         racket/contract
         racket/file
         racket/list
         racket/match
         racket/port
         racket/runtime-path
         racket/string
         xml)

(provide (all-defined-out))

(module+ test
  (require rackunit))

(define-syntax (define-explained-contract stx)
  (syntax-case stx ()
    [(_ (NAME VAL) EXPECTED TEST-EXPR)
     #'(define NAME
         (flat-contract-with-explanation
          (λ (VAL)
            (cond
              [TEST-EXPR]
              [else
               (λ (blame)
                 (raise-blame-error blame VAL '(expected: EXPECTED given: "~e") VAL))]))
          #:name 'NAME))]))

;; ~~ Tagged X-expressions ~~~~~~~~~~~~~~~~~~~~~~~

;; Lightweight functions for internal use only; avoids a dependency on txexpr package.

(define-explained-contract (txexpr? v)
  "tagged X-expression"
  (and (list? v) (xexpr? v)))

(define (get-attrs tx)
  (match tx
    [(list* (? symbol?) (list (list (? symbol?) (? string?)) ...) elems) (cadr tx)]
    [(list* (? symbol?) elems) '()]))

(define (get-elements tx)
  (match tx
    [(list* tag (list (list (? symbol?) (? string?)) ...) elements) elements]
    [(list* tag elements) elements]))

(module+ test
  (check-equal? (get-attrs '(br)) '())
  (check-equal? (get-attrs '(div "hello")) '())
  (check-equal? (get-attrs '(div amp "hello")) '())
  (check-equal? (get-attrs '(div [[id "main"]] amp "hello")) '((id "main")))

  (check-equal? (get-elements '(br)) '())
  (check-equal? (get-elements '(div amp "hello")) '(amp "hello"))
  (check-equal? (get-elements '(div [[id "main"]])) '())
  (check-equal? (get-elements '(div [[id "main"]] amp "hello")) '(amp "hello")))

;; ~~ XML Utility functions ~~~~~~~~~~~~~~~~~~~~~~

;; Create CDATA from a string or txexpr and undo any entity escaping in the result.
(define (as-cdata v)
  (define entities (hash "&amp;" "&" "&lt;" "<" "&gt;" ">"))
  (define cdata-str
    (cond [(txexpr? v)
           (regexp-replace* #rx"&amp;|&lt;|&gt;" (xexpr->string v) (lambda (e) (hash-ref entities e)))]
          [else v]))
  (cdata 'racket 'racket (format "<![CDATA[~a]]>" (string-replace cdata-str "]]>" "]]&gt;"))))

(module+ test
  ;; String input: no escaping in result
  (check-equal? (as-cdata "Hi & < >")
                (cdata 'racket 'racket "<![CDATA[Hi & < >]]>"))
  ;; Txexpr input: no escaping in result
  (check-equal? (as-cdata '(div (p "Hi & < >")))
                (cdata 'racket 'racket "<![CDATA[<div><p>Hi & < ></p></div>]]>"))
  ;; …but DO escape the forbidden string "]]>" which would prematurely end the block
  (check-equal? (as-cdata '(div (p "Hi ]]> whoops how did that get there")))
                (cdata 'racket 'racket "<![CDATA[<div><p>Hi ]]&gt; whoops how did that get there</p></div>]]>")))

;; Optional path to XSLT stylesheet
(define feed-xslt-stylesheet (make-parameter #f))

;; Convert an x-expression to a complete XML document
(define (xml-document xpr)
  (define xslt-path
    (match (feed-xslt-stylesheet)
      [(? url? u) (url->string u)]
      [v v]))
  (define xml-processing
    (cons (p-i 'racket 'racket 'xml "version=\"1.0\" encoding=\"UTF-8\"")
          (if xslt-path
              (list (p-i 'racket 'racket 'xml-stylesheet
                         (format "href=\"~a\" type=\"text/xsl\"" xslt-path)))
              '())))
  (document
   (prolog xml-processing #f '())
   (xexpr->xml xpr)
   '()))

;; ~~ HTML entity escaping ~~~~~~~~~~~~~~~~~~~~~~~

;; Named character entities other than the five in the XML spec (&lt; &gt; &amp; &apos; &quot;)
;; must be replaced with their numeric equivalents

(define-runtime-path entities.rktd "./entities.rktd")
(define entities (file->value entities.rktd)) ;; (Generated by build.rkt)

;; Replace any named character references with numeric ones.
;; (-> string? (listof (or/c string? symbol? valid-char?)))
(define (numberize-named-entities str)
  (match (regexp-match-positions* #rx"&[a-zA-Z]+;" str)
    ['()
     (list str)]
    [to-escape
     (let loop ([gap-end (string-length str)]
                [to-escape (reverse to-escape)]
                [acc null])
       (match to-escape
         ['()
          (if (zero? gap-end)
              acc
              (cons (substring str 0 gap-end)
                    acc))]
         [(cons (cons pos gap-start) to-escape)
          (define new-acc
            (if (= gap-start gap-end)
                acc
                (cons (substring str gap-start gap-end)
                      acc)))
          (define normalized-entity
            (string-trim (string-downcase (substring str pos gap-start)) #rx"&|;"))
          (loop pos
                to-escape
                (match (hash-ref entities normalized-entity #f)
                  ;; Most entities equate to a single codepoint, but some equate to two
                  [(list cpoint)
                   (cons cpoint new-acc)]
                  [(list cpoint1 cpoint2)
                   (cons cpoint1 (cons cpoint2 new-acc))]
                  [_ (cons (substring str pos gap-start) new-acc)]))]))]))
(module+ test
  (require rackunit)
  ;; The XML 5 get replaced with symbolic equivalents
  ;; First/last entities and adjacent entities get replaced properly
  (check-equal? (numberize-named-entities "&amp;&quot;&apos;&lt;&gt;")
                '(amp quot apos lt gt))
  ;; Others get replaced with numeric entities
  (check-equal? (numberize-named-entities "Copyright&copy; Trademark&trade; Recording copyright&copysr;")
                '("Copyright" 169 " Trademark" #x2122 " Recording copyright" #x2117))
  
  ;; Entities with multiple codepoints get both inserted
  (check-equal? (numberize-named-entities "This is one with multiple codepoints: &sqcaps;")
                '("This is one with multiple codepoints: " 8851 65024))
  ;; Non-existent entities get left in
  (check-equal? (numberize-named-entities "Total &madeup; mistake")
                '("Total " "&madeup;" " mistake"))
  ;; Avoid pointless copies
  (let ([already-sanitary-string "abcdefg"])
    (check-eq? (car (numberize-named-entities already-sanitary-string))
               already-sanitary-string)))

;; Converts a tagged X-expression into an XML string, with any non-XML entities in string elements
;; replaced with numeric equivalents. This string can in turn be used as the content of another
;; X-expression element with the type="html" attribute, so that when this second X-expression is
;; rendered as a string, the result is escaped HTML containing only valid XML entities.
(define (txexpr->safe-content-str tx)
  (xexpr->string
   (let loop ([x tx])
     (cond
       [(txexpr? x)
        `(,(car x)
          ,@(list (get-attrs x))
          ,@(append-map (λ (c)
                         (if (string? c)
                             (numberize-named-entities c)
                             (list (loop c))))
                       (get-elements x)))]
       [else x]))))

(module+ test
  (define judy-str "Punch &amp; Judy&apos;s friend George&trade;")

  (check-equal? (txexpr->safe-content-str `(div (p ,judy-str)))
                "<div><p>Punch &amp; Judy&apos;s friend George&#8482;</p></div>"))

(define (content->safe-element content element dialect preserve-cdata-struct?)
  `(,element
    ,@(if/sp (and (txexpr? content) (eq? dialect 'atom)) `[[type "html"]])
    ,(cond
       [(string? content)
        (let ([result (as-cdata content)]) (if preserve-cdata-struct? result (cdata-string result)))]
       [else (txexpr->safe-content-str content)])))

(module+ test
  (define content2 "<div>Hi ]]> whoops how did that get there</div>")
  ;; Includes type=text attribute for Atom
  (check-equal? (content->safe-element `(div (p "My trademark&trade;")) 'content 'atom #f)
                '(content ((type "html")) "<div><p>My trademark&#8482;</p></div>"))
  ;; Omit type attribute for RSS
  (check-equal? (content->safe-element `(div (p "My trademark&trade;")) 'description 'rss #f)
                '(description "<div><p>My trademark&#8482;</p></div>"))
  ;; String content encoded as CDATA
  (check-equal? (content->safe-element "<div>mischief managed: ]]></div>" 'content 'atom #f)
                '(content "<![CDATA[<div>mischief managed: ]]&gt;</div>]]>"))
  ;; preserve-cdata-struct? #t
  (check-true (cdata? (cadr (content->safe-element "x" 'content 'atom #t)))))


;; ~~ XML Display ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;; Convert an xexpr to a string with escaped and nicely-indented XML.
(define (indented-xml-string xpr #:document? [doc? #f])
  (define display-proc (if doc? display-xml display-xml/content))
  (define xml-str
    (with-output-to-string
      (λ ()
        (parameterize ([empty-tag-shorthand 'always])
          (display-proc (if doc? (xml-document xpr) (xexpr->xml xpr)) #:indentation 'peek)))))
  (string-trim xml-str #:right? #f))

(module+ test
  (define test-xpr
    `(feed (author (name "Punch & Judy"))
           (title [[type "text"]] "Punch & Judy's <friend> \"George\" Escapes!&trade;")
           (subtitle "Here & < > are escaped, but ' \" © ℗ ™ are not")
           (content [[type "html"]] ,(txexpr->safe-content-str `(div ,judy-str)))))
  (define expect-str #<<XML
<feed>
  <author>
    <name>Punch &amp; Judy</name>
  </author>
  <title type="text">Punch &amp; Judy's &lt;friend&gt; "George" Escapes!&amp;trade;</title>
  <subtitle>Here &amp; &lt; &gt; are escaped, but ' " © ℗ ™ are not</subtitle>
  <content type="html">&lt;div&gt;Punch &amp;amp; Judy&amp;apos;s friend George&amp;#8482;&lt;/div&gt;</content>
</feed>
XML
    )
  (check-equal? (indented-xml-string test-xpr) expect-str))

;; ~~ Other stuff ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;; Handy for splicing something or nothing into xexprs
(define-syntax (if/sp stx)
  (syntax-case stx ()
    [(_ check val) #'(if check (list val) '())]))