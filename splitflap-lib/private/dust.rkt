#lang racket/base

(require (for-syntax racket/base)
         (only-in net/url url? url->string)
         racket/contract
         racket/file
         racket/list
         racket/match
         racket/port
         racket/runtime-path
         racket/string
         xml)

(provide (all-defined-out))

(define-syntax (define-explained-contract stx)
  (syntax-case stx ()
    [(_ (NAME VAL) EXPECTED TEST-EXPR)
     #'(define NAME
         (flat-contract-with-explanation
          (位 (VAL)
            (cond
              [TEST-EXPR]
              [else
               (位 (blame)
                 (raise-blame-error blame VAL '(expected: EXPECTED given: "~e") VAL))]))
          #:name 'NAME))]))

;; ~~ Tagged X-expressions ~~~~~~~~~~~~~~~~~~~~~~~

;; Lightweight functions for internal use only; avoids a dependency on txexpr package.

(define-explained-contract (txexpr? v)
  "tagged X-expression"
  (and (list? v) (xexpr? v)))

(define (get-attrs tx)
  (match tx
    [(list* (? symbol?) (list (list (? symbol?) (? string?)) ...) elems) (cadr tx)]
    [(list* (? symbol?) elems) '()]))

(define (get-elements tx)
  (match tx
    [(list* tag (list (list (? symbol?) (? string?)) ...) elements) elements]
    [(list* tag elements) elements]))



;; ~~ XML Utility functions ~~~~~~~~~~~~~~~~~~~~~~

;; Create CDATA from a string or txexpr and undo any entity escaping in the result.
(define (as-cdata v)
  (define entities (hash "&amp;" "&" "&lt;" "<" "&gt;" ">"))
  (define cdata-str
    (cond [(txexpr? v)
           (regexp-replace* #rx"&amp;|&lt;|&gt;" (xexpr->string v) (lambda (e) (hash-ref entities e)))]
          [else v]))
  (cdata 'racket 'racket (format "<![CDATA[~a]]>" (string-replace cdata-str "]]>" "]]&gt;"))))

;; Optional path to XSLT stylesheet
(define feed-xslt-stylesheet (make-parameter #f))

;; Convert an x-expression to a complete XML document
(define (xml-document xpr)
  (define xslt-path
    (match (feed-xslt-stylesheet)
      [(? url? u) (url->string u)]
      [v v]))
  (define xml-processing
    (cons (p-i 'racket 'racket 'xml "version=\"1.0\" encoding=\"UTF-8\"")
          (if xslt-path
              (list (p-i 'racket 'racket 'xml-stylesheet
                         (format "href=\"~a\" type=\"text/xsl\"" xslt-path)))
              '())))
  (document
   (prolog xml-processing #f '())
   (xexpr->xml xpr)
   '()))

;; ~~ HTML entity escaping ~~~~~~~~~~~~~~~~~~~~~~~

;; Named character entities other than the five in the XML spec (&lt; &gt; &amp; &apos; &quot;)
;; must be replaced with their numeric equivalents

(define-runtime-path entities.rktd "./entities.rktd")
(define entities (file->value entities.rktd)) ;; (Generated by build.rkt)

;; Replace any named character references with numeric ones.
;; (-> string? (listof (or/c string? symbol? valid-char?)))
(define (numberize-named-entities str)
  (match (regexp-match-positions* #rx"&[a-zA-Z]+;" str)
    ['()
     (list str)]
    [to-escape
     (let loop ([gap-end (string-length str)]
                [to-escape (reverse to-escape)]
                [acc null])
       (match to-escape
         ['()
          (if (zero? gap-end)
              acc
              (cons (substring str 0 gap-end)
                    acc))]
         [(cons (cons pos gap-start) to-escape)
          (define new-acc
            (if (= gap-start gap-end)
                acc
                (cons (substring str gap-start gap-end)
                      acc)))
          (define normalized-entity
            (string-trim (string-downcase (substring str pos gap-start)) #rx"&|;"))
          (loop pos
                to-escape
                (match (hash-ref entities normalized-entity #f)
                  ;; Most entities equate to a single codepoint, but some equate to two
                  [(list cpoint)
                   (cons cpoint new-acc)]
                  [(list cpoint1 cpoint2)
                   (cons cpoint1 (cons cpoint2 new-acc))]
                  [_ (cons (substring str pos gap-start) new-acc)]))]))]))

;; Converts a tagged X-expression into an XML string, with any non-XML entities in string elements
;; replaced with numeric equivalents. This string can in turn be used as the content of another
;; X-expression element with the type="html" attribute, so that when this second X-expression is
;; rendered as a string, the result is escaped HTML containing only valid XML entities.
(define (txexpr->safe-content-str tx)
  (xexpr->string
   (let loop ([x tx])
     (cond
       [(txexpr? x)
        `(,(car x)
          ,@(list (get-attrs x))
          ,@(append-map (位 (c)
                         (if (string? c)
                             (numberize-named-entities c)
                             (list (loop c))))
                       (get-elements x)))]
       [else x]))))

(define (content->safe-element content element dialect preserve-cdata-struct?)
  `(,element
    ,@(if/sp (and (txexpr? content) (eq? dialect 'atom)) `[[type "html"]])
    ,(cond
       [(string? content)
        (let ([result (as-cdata content)]) (if preserve-cdata-struct? result (cdata-string result)))]
       [else (txexpr->safe-content-str content)])))


;; ~~ XML Display ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;; Convert an xexpr to a string with escaped and nicely-indented XML.
(define (indented-xml-string xpr #:document? [doc? #f])
  (define display-proc (if doc? display-xml display-xml/content))
  (define xml-str
    (with-output-to-string
      (位 ()
        (parameterize ([empty-tag-shorthand 'always])
          (display-proc (if doc? (xml-document xpr) (xexpr->xml xpr)) #:indentation 'peek)))))
  (string-trim xml-str #:right? #f))



;; ~~ Other stuff ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;; Handy for splicing something or nothing into xexprs
(define-syntax (if/sp stx)
  (syntax-case stx ()
    [(_ check val) #'(if check (list val) '())]))